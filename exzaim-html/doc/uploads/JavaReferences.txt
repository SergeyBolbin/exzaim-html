https://habrahabr.ru/post/169883/
http://www.javaportal.ru/java/articles/referenceclasses.html
http://www.dataved.ru/2010/05/java.html
http://samolisov.blogspot.ru/2011/09/phantomreferences-java.html

-----------------------------
Главной особенностью reference classes (ссылочных классов) является их способность обратиться к объекту, 
который уже может быть объявлен для обработки его «сборщиком мусора». До того как были представлены reference classes, 
были доступны только прямые ссылки на объекты.

Object obj = new Object();
Данная ссылка резервирует память под объект obj. До тех пор, пока ссылка на obj существует, «сборщик мусора» 
не освободит память, зарезервированную под него.

****************
Даже если объект после «обнуления» ссылки доступен для «сборщика мусора» - это не значит, что он будет убран при первом же его
(«сборщике») запуске, поскольку алгоритм работы «сборщика» постоянно изменяется.
Некоторые алгоритмы анализируют «долгоживущие» объекты реже, нежели объекты, имеющие небольшую продолжительность жизни 
в программе («маложивущие») Таким образом, объект, доступный для «сборщика» может быть так никогда и не убран. 
Данная ситуация может иметь место, если программа заканчивается до того как «сборщик мусора» начинает очищать память
 от не использующихся объектов. Поэтому вы никогда не можете гарантировать, что доступный «сборщику мусора» объект 
будет действительно убран.
*****************

Strongly reachable (прямо доступный) – к такому объекту можно получить доступ только посредством прямой ссылки.

Softly reachable (мягко доступный) – к такому объекту нельзя получить доступ через прямую ссылку, он может быть доступен только посредством SoftReference.

Weakly reachable (слабо доступный) – не может быть доступным через прямую и SoftReference ссылки. К такому объекту можно обратиться лишь посредством WeakReference.

Phantomly reachable (фантомно дотупный) – объект соответственно не может быть доступен посредством SoftReference и WeakReference, поскольку его использование было завершено. Обратиться к нему можно лишь при помощи PhantomReference ссылки.

Clear – установка полей объекта в null и объявление объекта, к которому происходит обращение, как finalizable.


package java.lang.ref
public abstract class Reference<T> {
	private T referent; 
	volatile ReferenceQueue<? super T> queue;
	
	public T get()
	public void clear()
	
	public boolean enqueue()
}


--------------------------------------------------------------------------------------------------------------------------------
Soft reference:

Идея состоит в том, что вы ссылаетесь на объект посредством SoftReference и все эти ссылки будут гарантированно очищены 
прежде чем JVM сообщит о завершении очистки памяти «сборщиком мусора». 
Основной момент заключается в том, что при запуске «сборщика мусора» объекты доступные посредством SoftReference
и на которые вы ссылаетесь могут быть убраны, а могут быть и не убраны. 
Будет ли объект убран «сборщиком», или нет – зависит от его («сборщика») алгоритма в данном цикле работы и от объема
свободной памяти в этот момент.


GC начал свою работу и проходит по всем объектам в куче. 

В случае, если объект в куче это Reference, то GC помещает этот объект в специальную очередь в которой лежат
все Reference объекты. 

После прохождения по всем объектам GC берет очередь Reference объектов и по каждому из них решает удалять его из памяти или нет. 

Как именно принимается решение об удалении объекта — зависит от JVM. 

GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError. 

SoftReference это наш механизм кэширования объектов в памяти, 
но в критической ситуации, когда закончится доступная память, 
GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.


SoftReference {
	private static long clock //Каждый раз при запуске GC, он сетит текущее время в переменную clock
	private long timestamp //в timestamp записывается текущее значение clock. timestamp обновляется каждый раз при вызове метода get() 

	public T get() {
        T o = super.get();
        if (o != null && this.timestamp != clock)
            this.timestamp = clock;
        return o;
    }

}
I - время с последнего обращения к объекту (get() )
F - кол-во свободного места в куче (мб)
-XX:SoftRefLRUPolicyMSPerMB default = 1000ms

I <= F * MSPerMB - не удаляем объект (т.о. переживет минимум 1 запуск ГЦ)

Применения: 
Soft references are most often used to implement memory-sensitive caches.
java.lang.Class тоже использует SoftReference для кэширования. Он кэширует данные о конструкторах, методах и полях класса. 
Class — разработчики создали soft-ссылку на массив конструкторов, полей и методов


------------------------------------------------------------------------------------------------------------------------------

Weak Reference

Когда GC определяет, что объект доступен только через weak-ссылки, то этот объект «сразу» удаляется из памяти
Итак, запустился GC и определил что объект доступен только через weak-ссылки.
Сначала GC очистит weak-ссылку, то есть weakRef.get() – будет возвращать null.
Потом weakRef будет добавлен в queue и соответственно queue.poll() вернет ссылку на weakRef. 

«Слабые» ссылки также полезны для объектов, которые могут иметь либо продолжительный цикл жизни, либо легко быть созданы заново.
 Основная идея в том, что если «сборщик мусора» найдет объект, который может быть доступен посредством WeakReference – 
 то он уберет его. Однако заметьте, что может потребоваться несколько запусков «сборщика мусора» 
 прежде чем он обнаружит подобный объект.

Применение

WeakHashMap
Это реализация Map<K,V> которая хранит ключ, используя weak-ссылку
когда GC удаляет ключ с памяти, то удаляется вся запись с Map.
При добавлении новой пары <ключ, значение>, создается WeakReference для ключа и в конструктор передается ReferenceQueue.
Когда GC удаляет ключ с памяти, то ReferenceQueue возвращает соответствующий WeakReference для этого ключа.
После этого соответствующий Entry удаляется с Map. 

WeakReference используется во многих классах – Thread, ThreadLocal, ObjectOutpuStream, Proxy, LogManager.
--------------------------------------------------------------------------------------------------------------------------------

Phantom Reference

PhantomReference class полезен в том случае, когда необходимо сохранить след объекта до того как он будет удален «сборщиком». Фантомная ссылка должна использоваться совместно с классом ReferenceQueue. ReferenceQueue необходим, поскольку он выполняет роль механизма предупреждения. Когда «сборщик мусора» находит объект, который может быть «фантомно-доступным» - этот объект помещается в свой класс ReferenceQueue. Помещение «фантомно-доступного» объекта в ReferenceQueue свидетельствует о том, что данный объект не используется и «сборщик мусора» готов его убрать из памяти. Это позволяет вам принять меры еще до того как в памяти произойдет очистка объекта.

Особенностей у этого типа ссылок две. 
Первая это то, что метод get() всегда возвращает null. 
Именно из-за этого PhantomReference имеет смысл использовать только вместе с ReferenceQueue. 
Вторая особенность – в отличие от SoftReference и WeakReference, 
GC добавит phantom-ссылку в ReferenceQueue послетого как выполниться метод finalize(). 
То есть фактически, в отличии от SoftReference и WeakReference, объект еще есть в памяти.

Проблемы, возникающие при использовании метода finalize(): 
переопределение этого метода позволяет нам очистить ресурсы связанные с объектом. 

- GC запускается непредсказуемо, мы не можем знать когда будет выполнен метод finalize()
- Методы finalize() запускаются в одном потоке, по очереди. И до тех пор, пока не выполниться этот метод, объект не может быть удален с памяти
- Нет гарантии, что этот метод будет вызван. JVM может закончить свою работу и при этом объект так и не станет недоступным.
- Во время выполнения метода finalize() может быть создана strong-ссылка на объект и он не будет удален, но в следующий раз, когда GC увидит что объект более недоступен, метод finalize() больше не выполнится.

 Этот тип ссылок в комбинации с ReferenceQueue позволяет нам узнать, когда объект более недоступен и на него нет других ссылок. Это позволяет нам сделать очистку ресурсов, используемых объектом, на уровне приложения. 
 В отличие от finalize() мы сами контролируем процесс очистки ресурсов.
 
 
PhantomReference нужно помнить о следующих вещах:
1. Контракт гарантирует что ссылка появится в очереди после того как GC заметит что объект доступен 
только по phantom-ссылкам и перед тем как объект будет удален из памяти. 
Контракт не гарантирует, что эти события произойдут одно за другим. 
В реальности между этими событиями может пройти сколько угодно времени. 
Поэтому не стоит опираться на PhantomReference для очистки критически важных ресурсов.

2. Выполнение метода finalize() и добавление phantom-ссылки в ReferenceQueue выполняется в разных запусках GC. 
Поэтому если у объекта переопределен метод finalize() то для его удаления необходимы 3 запуска GC, 
а если метод не переопределен, то нужно, минимум, 2 запуска GC


----------------------------------------------

import java.lang.ref.*;


class MyObject
{
    protected void finalize() throws Throwable
    {
        System.out.println("In finalize method for this object: " +
                this);
    }
}

public class MainJava {

    public static void main(String args[]) throws InterruptedException {
        release();
    }

    public static void release() throws InterruptedException {
        //Create an object
        MyObject obj = new MyObject();
        System.out.println("object is " + obj);

        //Create a reference queue
        ReferenceQueue rq = new ReferenceQueue();

        //Create a weakReference to obj and associate our reference queue
        Reference wr = createReference(obj, rq, "Weak");

        //Check to see if it's on the ref queue yet
        System.out.println("Polling the reference queue returns " + rq.poll());
        System.out.println("Getting the referent from the weak reference returns " + wr.get());

        System.out.println("Set the obj reference to null and call GC");
        obj = null;
        System.gc();

        Thread.sleep(1000);

        System.out.println("Polling the reference queue returns " + rq.poll());
        System.out.println("Getting the referent from the weak reference returns " + wr.get());
    }

    private static Reference createReference(Object obj, ReferenceQueue queue, String type) {
        switch (type) {
            case "Soft": return new SoftReference(obj, queue);
            case "Weak": return new WeakReference(obj, queue);
            case "Phantom": return new PhantomReference(obj, queue);
        }

        return null;
    }
}
